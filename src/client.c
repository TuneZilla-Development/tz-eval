/**
 * @file client.c
 * @brief Client Program for TuneZilla Software Software Engineer Applicants
 *
 * This file contains the main entry point and associated functions for the evaluation client program.
 * The program processes command-line arguments and performs specific tasks based on the input.
 *
 * @date 2024-07
 * 
 * @note DO NOT EDIT THIS FILE
 */

#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <getopt.h>

#include "lib/version.h"
#include "lib/msg.h"
#include "lib/log.h"

#include "tasks.h"

/**
 * @brief Prints the usage information for the program and exits.
 * 
 * @note Do not edit this function.
 *
 * @param progname The name of the program, typically argv[0]
 */
static void usage(char * progname)
{
    fprintf(stderr, "%s - Client Program for TuneZilla Software Software Engineer Applicants (2024/07)\n", progname);
    fprintf(stderr, "Usage: %s [<task-num>]\n", progname);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "\t[<task-num>]         : The task number to run individually. See README.md (Default: Run all tasks)\n");
    fprintf(stderr, "\n");

    exit(1);
}
/**
 * @brief The main entry point of the client program.
 *
 * This function is the main entry point of the program. It processes command-line arguments
 * and determines which task to run based on the provided input. If no specific task number
 * is provided, it runs all tasks by default.
 * 
 * @note Do not edit this function.
 *
 * @param argc The number of command-line arguments.
 * @param argv An array of command-line arguments.
 * @return int The exit status of the program.
 */
int main (int argc, char **argv) {
    version(stdout, "Client Program - TZ Dev Evaluation");

    int result = 0; // OK
    int task_num = -1; // All tests

    int i;
    // Parse Optional Arguments
    while ((i = getopt(argc, argv, "")) != EOF)
    {
        switch (i)
        {
            default:
            {
                usage(argv[0]);
                break;
            }
        }
    }
    // Parse Positional Arguments
    if ((argc - optind) > 1)
    {
        // Too many arguments!
        usage(argv[0]);
    }
    else if((argc - optind) == 1)
    {
        task_num = strtol(argv[optind], NULL, 16);
        if(task_num < 0) {
            printf("ERROR: Invalid task_num must be positive.\n");
        }
    }

    // Open a log file
    if(log_open("client.log") != 0) {
        printf("ERROR: Could not open log\n");
        return 1; // ERROR
    }
    log_write("\nStarted %s\n", argv[0], task_num);
    
    for (int i = 0; i < NUM_OF_TASKS; i++) {
        if(task_num > 0 && task_num != task_list[i].task_num) {
            // Task number was provided. Skip non-matching tasks.
            printf("%s Skipped.\n", task_list[i].task_name);
            continue;
        }

        // Open the message pipe (this connects to our server process)
        if(msg_connect(task_list[i].task_num) != MSG_OK) {
            printf("ERROR: Could not connect to pipe. Check that server.exe is running.\n");
            result = 1; // ERROR;
            goto cleanup;
        }

        printf("\n%s Starting...\n", task_list[i].task_name);

        result = run_task((uint8_t)task_list[i].task_num);

        // Print the result code
        if(result == TASK_NOT_IMPLEMENTED) {
            printf("ERROR: %s is not implemented. See src/tasks.c\n", task_list[i].task_name);
        } else if(result != TASK_OK) {
            printf("ERROR: %s returned error: %d\n", task_list[i].task_name, result);
        } else {
            printf("%s SUCCESS\n", task_list[i].task_name);
        }
        
        // Close the pipe (if connected)
        msg_close();
    }

cleanup:
    // Close the log (if open)
    log_close();

    return result;
}
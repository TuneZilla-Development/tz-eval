/**
 * @file log.c
 * @brief Helper function for logging messages to a log file.
 * 
 * @date 2024-07
 * 
 * @note DO NOT EDIT THIS FILE
 */

#include <stdio.h>
#include <stdint.h>
#include <time.h>
#include <windows.h>

#include "log.h"
#include <stdarg.h>

#ifndef USE_LOG
#define USE_LOG 1
#endif

#define MAX_BYTES_HEADER_LEN    (128)

static FILE * _log = NULL;

/**
 * @brief Function to return the current timestamp.
 * 
 * @note Do not edit this function.
 *
 * @returns The timestamp in the format: "9999-12-31 23:59:59.999"
 */
static char *timestamp(void) {
    static char buffer[sizeof "9999-12-31 23:59:59.999" * 2];
    SYSTEMTIME st;
    GetLocalTime(&st);

    snprintf(
        buffer,
        sizeof(buffer),
        "%04d-%02d-%02d %02d:%02d:%02d.%03d",
        st.wYear,
        st.wMonth,
        st.wDay,
        st.wHour,
        st.wMinute,
        st.wSecond,
        st.wMilliseconds
    );

    return buffer;
}

/**
 * @brief Function to open a log file
 * 
 * If logging is enabled (USE_LOG is set to 1).
 * 
 * @note Do not edit this function.
 *
 * @param filename The filename to use for the log.
 * @returns 0 on success, 1 on failure.
 */
int log_open(char * filename) {
#if USE_LOG==1
    if(_log != NULL) {
        // Close existing log
        log_close();
    }

    // Open the log (append)
    if((_log = fopen((const char *)filename, "a")) == NULL) {
        // Failed to open
        _log = NULL;
        return 1; // ERR
    }
#endif // USE_LOG
    return 0; // OK
}

/**
 * @brief Function to close the log file
 * 
 * If logging is enabled (USE_LOG is set to 1).
 * 
 * @note Do not edit this function.
 *
 * @returns 0 on success
 */
int log_close() {
#if USE_LOG==1
    if(_log != NULL) {
        // Close the log
        fclose(_log);
        _log = NULL;
    }
#endif // USE_LOG
    return 0; // OK
}

/**
 * @brief Writes a formatted log message to the log file.
 *
 * This function writes a formatted message to the log file if logging is enabled (USE_LOG is set to 1).
 * It uses variadic arguments to handle the formatting.
 *
 * @note Do not edit this function.
 *
 * @param __format The format string (similar to printf).
 * @param ... Additional arguments for the format string.
 */
void log_write(const char *__format, ...) {
#if USE_LOG==1
    // Write the formatted string..
    va_list args;
    va_start(args, __format);

    vfprintf(_log, __format, args);

    // Clean up the variadic arguments
    va_end(args);
#endif // USE_LOG
}

/**
 * @brief Prints the timestamp and formatted log message to the log file.
 *
 * This function writes the Timestamp followed by the formatted message to
 * the log file if logging is enabled (USE_LOG is set to 1). It uses variadic
 * arguments to handle the formatting.
 *
 * @note Do not edit this function.
 *
 * @param __format The format string (similar to printf).
 * @param ... Additional arguments for the format string.
 */
void log_print(const char *__format, ...) {
#if USE_LOG==1

    // Write the timestamp
    fprintf(_log, "[%s] ", timestamp());

    // Write the formatted string..
    va_list args;
    va_start(args, __format);

    vfprintf(_log, __format, args);

    // Clean up the variadic arguments
    va_end(args);
#endif // USE_LOG
}

/**
 * @brief Logs an array of bytes, printing a new line every 16 bytes.
 *
 * This function logs an array of bytes, formatting the output with a header
 * and prefix. A new line is printed every 16 bytes, with each line starting
 * with a timestamp and the prefix. The formatted header is printed on the
 * first line only.
 * 
 * @note Do not edit this function.
 *
 * @param bytes A pointer to the array of bytes to be logged.
 * @param len The length of the byte array.
 * @param prefix A string prefix to be printed before the bytes.
 * @param header_format The format string for the header (similar to printf). Printed on the first line only
 * @param ... Additional arguments for the header format string.
 */
void log_bytes(const uint8_t * bytes, uint32_t len, const char * prefix, const char * header_format, ...) {
    // [TIMESTAMP] <header_format> [<prefix>] 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
    // [TIMESTAMP]                 [<prefix>] 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F ...   
#if USE_LOG==1
    char header[MAX_BYTES_HEADER_LEN];
    va_list args;

    // Format the header string with variable arguments
    va_start(args, header_format);
    vsnprintf(header, MAX_BYTES_HEADER_LEN, header_format, args);
    va_end(args);

    // Print the header with optional prefix
    if(prefix[0] == '\0') {
        log_print("%s", header);
    } else {
        log_print("%s %s", header, prefix);
    }

    // Replace the header with spaces (for subsequent lines)
    memset(header, ' ', strlen(header));
    header[strlen(header)] = '\0';

    for (uint32_t i = 0; i < len; i++) {
        // Start a new line every 16 bytes. Each line is padded to match the header..
        if ((i % 16 == 0) && i) {
            log_write("\n");
            if(prefix[0] == '\0') {
                log_print("%s", header);
            } else {
                log_print("%s %s", header, prefix);
            }
        }
        // Write the byte in HEX
        log_write(" %02X", bytes[i]);
    }
    log_write("\n");
#endif // USE_LOG
}


/**
 * @brief Print an array of bytes to stdout, printing a new line every 16 bytes.
 *
 * This function prints an array of bytes, formatting the output with a header
 * and prefix. A new line is printed every 16 bytes, with each line starting
 * with the prefix. The formatted header is printed on the first line only.
 * 
 * @note Do not edit this function.
 *
 * @param bytes A pointer to the array of bytes to be printed.
 * @param len The length of the byte array.
 * @param prefix A string prefix to be printed before the bytes.
 * @param header_format The format string for the header (similar to printf). Printed on the first line only
 * @param ... Additional arguments for the header format string.
 */
void print_bytes(const uint8_t * bytes, uint32_t len, const char * prefix, const char * header_format, ...) {
    // <header_format> [<prefix>] 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
    //                 [<prefix>] 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F ...   
    char header[MAX_BYTES_HEADER_LEN];
    va_list args;

    // Format the header string with variable arguments
    va_start(args, header_format);
    vsnprintf(header, MAX_BYTES_HEADER_LEN, header_format, args);
    va_end(args);

    // Print the header with optional prefix
    if(prefix[0] == '\0') {
        printf("%s", header);
    } else {
        printf("%s %s", header, prefix);
    }

    // Replace the header with spaces (for subsequent lines)
    memset(header, ' ', strlen(header));
    header[strlen(header)] = '\0';

    for (uint32_t i = 0; i < len; i++) {
        // Start a new line every 16 bytes. Each line is padded to match the header..
        if ((i % 16 == 0) && i) {
            if(prefix[0] == '\0') {
                printf("\n%s", header);
            } else {
                printf("\n%s %s", header, prefix);
            }
        }
        // Write the byte in HEX
        printf(" %02X", bytes[i]);
    }
    printf("\n");
}
/**
 * @file msg.c
 * @brief Implementation of message layer for connecting client/server processes.
 *
 * This file contains functions for opening, and closing pipes and sending/receiving
 * messages through that pipe
 * 
 * @date 2024-07
 * 
 * @note DO NOT EDIT THIS FILE
 */

#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include "log.h"

#include "msg.h"

/**
 * @brief Handle for the message pipe.
 */
static HANDLE hPipe = INVALID_HANDLE_VALUE;

/**
 * @brief Send a message using the connected pipe.
 * 
 * Will log messages/errors using log_print().
 * 
 * @note Do not edit this function.
 *
 * @param msg A pointer to the message to be sent.
 * @param len The length of the message to be sent (max 8 bytes).
 * @return MSG_OK on success, MSG_ERROR on failure.
 */
int msg_send(uint8_t* msg, uint8_t len) {
    if (hPipe == INVALID_HANDLE_VALUE) {
        log_print("ERROR: Pipe handle is invalid.\n");
        return MSG_ERROR;
    }
    
    if(len == 0) {
        // Must send data
        return MSG_ERROR;
    } else if (len > 8) {
        // Limit len to 8 bytes
        len = 8;
    }

    DWORD bytesWritten;
    BOOL result = WriteFile(hPipe, msg, len, &bytesWritten, NULL);

    if (!result || bytesWritten != len) {
        log_print("ERROR: Writing to pipe failed.\n");
        return MSG_ERROR;
    }

    // Flush the pipe buffer
    if (!FlushFileBuffers(hPipe)) {
        log_print("ERROR: Flushing pipe buffer failed.\n");
        return MSG_ERROR;
    }

    // Print the message to the log.
    log_bytes(msg, bytesWritten, "-->", "\tMSG");

    return MSG_OK;
}

/**
 * @brief Receive a message from the connected pipe with a timeout.
 * 
 * Will log messages/errors using log_print().
 * 
 * @note Do not edit this function.
 *
 * @param msg A pointer to the buffer to store the received message (length >= 8).
 * @param len A pointer to store the length of the received message (max 8 bytes).
 * @param timeout_ms The timeout in milliseconds for the read operation.
 * @return MSG_OK on success, MSG_ERROR on failure, MSG_TIMEOUT if no message was received within timeout_ms.
 */
int msg_recv_to(uint8_t* msg, uint8_t* len, uint32_t timeout_ms) {
    if (hPipe == INVALID_HANDLE_VALUE) {
        log_print("ERROR: Pipe handle is invalid.\n");
        return MSG_ERROR;
    }

    DWORD bytesRead;
    BOOL result;
    OVERLAPPED overlapped = {0};
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (overlapped.hEvent == NULL) {
        log_print("ERROR: CreateEvent failed.\n");
        return MSG_ERROR;
    }

    result = ReadFile(hPipe, msg, MSG_BUFFER_SIZE, &bytesRead, &overlapped);
    if (!result && GetLastError() != ERROR_IO_PENDING) {
        log_print("ERROR: Reading from pipe failed (%d)\n", GetLastError());
        CloseHandle(overlapped.hEvent);
        return MSG_ERROR;
    }
    DWORD waitResult = WaitForSingleObject(overlapped.hEvent, timeout_ms);
    if (waitResult == WAIT_TIMEOUT) {
        log_print("ERROR: Read from pipe timed out.\n");
        CancelIo(hPipe); // Cancel the IO operation
        CloseHandle(overlapped.hEvent);
        return MSG_TIMEOUT;
    } else if (waitResult != WAIT_OBJECT_0) {
        log_print("ERROR: WaitForSingleObject failed.\n");
        CloseHandle(overlapped.hEvent);
        return MSG_ERROR;
    }

    if (!GetOverlappedResult(hPipe, &overlapped, &bytesRead, FALSE)) {
        log_print("ERROR: GetOverlappedResult failed.\n");
        CloseHandle(overlapped.hEvent);
        return MSG_ERROR;
    }

    if(bytesRead > 8) {
        // Limit the result to 8 bytes
        bytesRead = 8;
    }
    
    if (len != NULL) {
        *len = bytesRead;
    }

    // Print the message to the log.
    log_bytes(msg, bytesRead, "<--", "\tMSG");

    CloseHandle(overlapped.hEvent);
    return MSG_OK;
}

/**
 * @brief Receive a message from the connected pipe.
 * 
 * @note Do not edit this function.
 *
 * @param msg A pointer to the buffer to store the received message (length >= 8).
 * @param len A pointer to store the length of the received message (max 8 bytes).
 * @return MSG_OK on success, MSG_ERROR on failure, MSG_TIMEOUT if no message was received within 1s.
 */
int msg_recv(uint8_t* msg, uint8_t* len) {
    return msg_recv_to(msg, len, MSG_RECV_TIMEOUT_MS);
}

/**
 * @brief Create a pipe as the server / host.
 * 
 * Will log messages/errors using log_print().
 * 
 * @return MSG_OK on success, MSG_ERROR on failure.
 */
int msg_open() {
    hPipe = CreateNamedPipe(
        MSG_PIPE_NAME,
        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
        1,        // Number of instances
        MSG_BUFFER_SIZE,
        MSG_BUFFER_SIZE,
        0,
        NULL
    );

    if (hPipe == INVALID_HANDLE_VALUE) {
        log_print("ERROR: Unable to create named pipe.\n");
        return MSG_ERROR;
    }

    bool connected = ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
    if (!connected) {
        log_print("ERROR: Unable to connect to the client.\n");
        CloseHandle(hPipe);
        return MSG_ERROR;
    }

    return MSG_OK;
}

/**
 * @brief Connects to an existing pipe as the client.
 * 
 * Waits for upto 1 second. Will log messages/errors using log_print().
 * 
 * @note Do not edit this function.
 *
 * @return MSG_OK on success, MSG_ERROR on failure, MSG_TIMEOUT if a connection was not made within 1s
 */
int msg_connect(uint8_t task_num) {
    // Wait upto 1000 ms
    DWORD startTime = GetTickCount();
    while (1) {
        hPipe = CreateFile(
            MSG_PIPE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OVERLAPPED,
            NULL
        );
        if (hPipe != INVALID_HANDLE_VALUE) {
            // Opened the pipe!
            break;
        }

        if(GetLastError() != ERROR_PIPE_BUSY) {
            log_print("ERROR: Unable to open pipe. Error: %d\n", GetLastError());
            return MSG_ERROR;
        }
        
        // Check if we've waited too long.
        if(GetTickCount() - startTime >= 1000) {
            log_print("ERROR: Unable to open pipe. Timed out while waiting\n");
            return MSG_TIMEOUT;
        }

        // Wait 50ms before trying again
        Sleep(50);
    }
    

    // Send the task_num using opcode 0xFF
    log_print("Connected to pipe. Setting server task to %02X..\n", task_num);
    uint8_t msg[2] = {0xFF, task_num};
    msg_send(msg, 2);

    return MSG_OK;    
}

/**
 * @brief Closes the pipe connection.
 * 
 * Will log messages using log_print().
 * 
 * @note Do not edit this function.
 *
 * @return MSG_OK
 */
int msg_close() {
    if (hPipe != INVALID_HANDLE_VALUE) {
        CloseHandle(hPipe);
    }
    log_print("Disconnected from pipe.\n");
    hPipe = INVALID_HANDLE_VALUE;
    return MSG_OK;
}